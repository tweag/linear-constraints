@article{LinearHaskell,
 author = {Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Peyton Jones, Simon and Spiwack, Arnaud},
 title = {Linear Haskell: Practical Linearity in a Higher-order Polymorphic Language},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {January 2018},
 volume = {2},
 number = {POPL},
 month = dec,
 year = {2017},
 issn = {2475-1421},
 pages = {5:1--5:29},
 articleno = {5},
 numpages = {29},
 url = {http://doi.acm.org/10.1145/3158093},
 doi = {10.1145/3158093},
 acmid = {3158093},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {GHC, Haskell, laziness, linear logic, linear types, polymorphism, typestate},
}

@article{OutsideIn,
 title={OutsideIn(X) Modular type inference with local assumptions},
 volume={21},
 doi={10.1017/S0956796811000098},
 number={4-5},
 journal={Journal of Functional Programming},
 publisher={Cambridge University Press},
 author={Vytiniotis, Dimitrios and Peyton Jones, Simon and Schrijvers, Tom and Sulzmann, Martin},
 year={2011},
 pages={333–412}
}

@article{resource-management-for-ll-proof-search,
title = "Efficient resource management for linear logic proof search",
journal = "Theoretical Computer Science",
volume = "232",
number = "1",
pages = "133 - 163",
year = "2000",
issn = "0304-3975",
doi = "https://doi.org/10.1016/S0304-3975(99)00173-5",
url = "http://www.sciencedirect.com/science/article/pii/S0304397599001735",
author = "Iliano Cervesato and Joshua S. Hodas and Frank Pfenning",
keywords = "Linear logic, Theorem proving, Logic programming",
abstract = "The design of linear logic programming languages and theorem provers opens a number of new implementation challenges not present in more traditional logic languages such as Horn clauses (Prolog) and hereditary Harrop formulas (λProlog and Elf). Among these, the problem of efficiently managing the linear context when solving a goal is of crucial importance for the use of these systems in non-trivial applications. This paper studies this problem in the case of Lolli [10], though its results have application to other systems including those based on linear type theory. We first give a proof-theoretic presentation of the operational semantics of this language as a resolution calculus. We then present a series of resource management systems designed to eliminate the non-determinism in the distribution of linear formulas that undermines the efficiency of a direct implementation of this system."
}

@article{hh-ll,
title = "Logic Programming in a Fragment of Intuitionistic Linear Logic",
journal = "Information and Computation",
volume = "110",
number = "2",
pages = "327 - 365",
year = "1994",
issn = "0890-5401",
doi = "https://doi.org/10.1006/inco.1994.1036",
url = "http://www.sciencedirect.com/science/article/pii/S0890540184710364",
author = "J.S. Hodas and D. Miller",
abstract = "When logic programming is based on the proof theory of intuitionistic logic, it is natural to allow implications in goals and in the bodies of clauses. Attempting to prove a goal of the form D ⊃ G from the context (set of formulas) Γ leads to an attempt to prove the goal G in the extended context Γ ∪ {D}. Thus contexts, represented as the left-hand side of intuitionistic sequents, grow as stacks during the bottom-up search for a cut-free proof. While such an intuitionistic notion of context provides for elegant specifications of many computations, contexts can be made more expressive and flexible if they are based on linear logic. After presenting two equivalent formulations of a fragment of linear logic, we show that the fragment has a goal-directed interpretation, thereby partially justifying calling it a logic program-ming language. Logic programs based on the intuitionistic theory of hereditary Harrop formulas can be modularly embedded into this linear logic setting. Programming examples taken from theorem proving, natural language parsing, and data base programming are presented: each example requires a linear, rather than intuitionistic, notion of context to be modeled adequately. An interpreter for this logic programming language must address the problem of splitting contexts; that is, in the attempt to prove a multiplicative conjunction (tensor), say G1 ⊗ G2, from the context Δ the latter must be split into disjoint contexts Δ1 and Δ2 for which G1 follows from Δ1 and G2 follows from Δ2. Since there is an exponential number of such splits, it is important to delay the choice of a split as much as possible. A mechanism for the lazy splitting of contexts is presented based on viewing proof search as a process that takes a context, consumes part of it, and returns the rest (to be consumed elsewhere). In addition, we use collections of Kripke interpretations indexed by a commutative monoid to provide models for this logic programming language and show that logic programs admit canonical models."
}

@misc{shulman2018linear,
      title={Linear logic for constructive mathematics},
      author={Michael Shulman},
      year={2018},
      eprint={1805.07518},
      archivePrefix={arXiv},
      primaryClass={math.LO}
}

@InProceedings{AtsLinearViews,
author="Zhu, Dengping
and Xi, Hongwei",
editor="Hermenegildo, Manuel V.
and Cabeza, Daniel",
title="Safe Programming with Pointers Through Stateful Views",
booktitle="Practical Aspects of Declarative Languages",
year="2005",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="83--97",
abstract="The need for direct memory manipulation through pointers is essential in many applications. However, it is also commonly understood that the use (or probably misuse) of pointers is often a rich source of program errors. Therefore, approaches that can effectively enforce safe use of pointers in programming are highly sought after. ATS is a programming language with a type system rooted in a recently developed framework Applied Type System, and a novel and desirable feature in ATS lies in its support for safe programming with pointers through a novel notion of stateful views. In particular, even pointer arithmetic is allowed in ATS and guaranteed to be safe by the type system of ATS. In this paper, we give an overview of this feature in ATS, presenting some interesting examples based on a prototype implementation of ATS to demonstrate the practicality of safe programming with pointer through stateful views.",
isbn="978-3-540-30557-6"
}

@article{QualifiedTypes,
title = "A theory of qualified types",
journal = "Science of Computer Programming",
volume = "22",
number = "3",
pages = "231 - 256",
year = "1994",
issn = "0167-6423",
doi = "https://doi.org/10.1016/0167-6423(94)00005-0",
url = "http://www.sciencedirect.com/science/article/pii/0167642394000050",
author = "Mark P. Jones",
abstract = "This paper describes a general theory of overloading based on a system of qualified types. The central idea is the use of predicates in the type of a term, restricting the scope of universal quantification. A corresponding semantic notion of evidence is introduced and provides a uniform framework for implementing applications of this system, including Haskell style type classes, extensible records and subtyping. Working with qualified types in a simple, implicitly typed, functional language, we extend the Damas-Milner approach to type inference. As a result, we show that the set of all possible typings for a given term can be characterized by a principal type scheme, calculated by a type inference algorithm."
}

@article{altenkirch2010quantum,
  title={The quantum IO monad},
  author={Altenkirch, Thorsten and Green, Alexander S},
  journal={Semantic Techniques in Quantum Computation},
  pages={173--205},
  year={2010},
  publisher={Cambridge University Press}
}

@inproceedings{quantified-constraints,
author = {Bottu, Gert-Jan and Karachalias, Georgios and Schrijvers, Tom and Oliveira, Bruno C. d. S. and Wadler, Philip},
title = {Quantified Class Constraints},
year = {2017},
isbn = {9781450351829},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3122955.3122967},
doi = {10.1145/3122955.3122967},
abstract = {Quantified class constraints have been proposed many years ago to raise the expressive power of type classes from Horn clauses to the universal fragment of Hereditiary Harrop logic. Yet, while it has been much asked for over the years, the feature was never implemented or studied in depth. Instead, several workarounds have been proposed, all of which are ultimately stopgap measures. This paper revisits the idea of quantified class constraints and elaborates it into a practical language design. We show the merit of quantified class constraints in terms of more expressive modeling and in terms of terminating type class resolution. In addition, we provide a declarative specification of the type system as well as a type inference algorithm that elaborates into System F. Moreover, we discuss termination conditions of our system and also provide a prototype implementation.},
booktitle = {Proceedings of the 10th ACM SIGPLAN International Symposium on Haskell},
pages = {148–161},
numpages = {14},
keywords = {Haskell, type classes, type inference},
location = {Oxford, UK},
series = {Haskell 2017}
}

@inproceedings{mezzo-permissions,
author = {Pottier, Fran\c{c}ois and Protzenko, Jonathan},
title = {Programming with Permissions in Mezzo},
year = {2013},
isbn = {9781450323260},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2500365.2500598},
doi = {10.1145/2500365.2500598},
abstract = {We present Mezzo, a typed programming language of ML lineage. Mezzo is equipped with a novel static discipline of duplicable and affine permissions, which controls aliasing and ownership. This rules out certain mistakes, including representation exposure and data races, and enables new idioms, such as gradual initialization, memory re-use, and (type)state changes. Although the core static discipline disallows sharing a mutable data structure, Mezzo offers several ways of working around this restriction, including a novel dynamic ownership control mechanism which we dub "adoption and abandon".},
booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
pages = {173–184},
numpages = {12},
keywords = {side effects, ownership, aliasing, static type systems},
location = {Boston, Massachusetts, USA},
series = {ICFP '13}
}

@InProceedings{liquid-haskell-abstract-refinement-types,
author="Vazou, Niki
and Rondon, Patrick M.
and Jhala, Ranjit",
editor="Felleisen, Matthias
and Gardner, Philippa",
title="Abstract Refinement Types",
booktitle="Programming Languages and Systems",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="209--228",
abstract="We present abstract refinement types which enable quantification over the refinements of data- and function-types. Our key insight is that we can avail of quantification while preserving SMT-based decidability, simply by encoding refinement parameters as uninterpreted propositions within the refinement logic. We illustrate how this mechanism yields a variety of sophisticated means for reasoning about programs, including: parametric refinements for reasoning with type classes, index-dependent refinements for reasoning about key-value maps, recursive refinements for reasoning about recursive data types, and inductive refinements for reasoning about higher-order traversal routines. We have implemented our approach in a refinement type checker for Haskell and present experiments using our tool to verify correctness invariants of various programs.",
isbn="978-3-642-37036-6"
}

@article{ats-lang,
  author    = {Hongwei Xi},
  title     = {Applied Type System: An Approach to Practical Programming with Theorem-Proving},
  journal   = {CoRR},
  volume    = {abs/1703.08683},
  year      = {2017},
  url       = {http://arxiv.org/abs/1703.08683},
  archivePrefix = {arXiv},
  eprint    = {1703.08683},
  timestamp = {Mon, 13 Aug 2018 16:47:04 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/Xi17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@article{10.1145/773473.178246,
author = {Launchbury, John and Peyton Jones, Simon L.},
title = {Lazy Functional State Threads},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {29},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/773473.178246},
doi = {10.1145/773473.178246},
abstract = {Some algorithms make critical internal use of updatable state, even though their external specification is purely functional. Based on earlier work on monads, we present a way of securely encapsulating stateful computations that manipulate multiple, named, mutable objects, in the context of a non-strict, purely-functional language.The security of the encapsulation is assured by the type system, using parametricity. Intriguingly, this parametricity requires the provision of a (single) constant with a rank-2 polymorphic type.},
journal = {SIGPLAN Not.},
month = jun,
pages = {24–35},
numpages = {12}
}

@inproceedings{st-monad,
author = {Launchbury, John and Peyton Jones, Simon L.},
title = {Lazy Functional State Threads},
year = {1994},
isbn = {089791662X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/178243.178246},
doi = {10.1145/178243.178246},
abstract = {Some algorithms make critical internal use of updatable state, even though their external specification is purely functional. Based on earlier work on monads, we present a way of securely encapsulating stateful computations that manipulate multiple, named, mutable objects, in the context of a non-strict, purely-functional language.The security of the encapsulation is assured by the type system, using parametricity. Intriguingly, this parametricity requires the provision of a (single) constant with a rank-2 polymorphic type.},
booktitle = {Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation},
pages = {24–35},
numpages = {12},
location = {Orlando, Florida, USA},
series = {PLDI '94}
}

@inproceedings{type-class-reflection,
author = {Kiselyov, Oleg and Shan, Chung-chieh},
title = {Functional Pearl: Implicit Configurations--or, Type Classes Reflect the Values of Types},
year = {2004},
isbn = {1581138504},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1017472.1017481},
doi = {10.1145/1017472.1017481},
abstract = {The configurations problem is to propagate run-time preferences throughout a program, allowing multiple concurrent configuration sets to coexist safely under statically guaranteed separation. This problem is common in all software systems, but particularly acute in Haskell, where currently the most popular solution relies on unsafe operations and compiler pragmas.We solve the configurations problem in Haskell using only stable and widely implemented language features like the type-class system. In our approach, a term expression can refer to run-time configuration parameters as if they were compile-time constants in global scope. Besides supporting such intuitive term notation and statically guaranteeing separation, our solution also helps improve the program's performance by transparently dispatching to specialized code at run-time. We can propagate any type of configuration data-numbers, strings, IO actions, polymorphic functions, closures, and abstract data types. No previous approach to propagating configurations implicitly in any language provides the same static separation guarantees.The enabling technique behind our solution is to propagate values via types, with the help of polymorphic recursion and higher-rank polymorphism. The technique essentially emulates local type-class instance declarations while preserving coherence. Configuration parameters are propagated throughout the code implicitly as part of type inference rather than explicitly by the programmer. Our technique can be regarded as a portable, coherent, and intuitive alternative to implicit parameters. It motivates adding local instances to Haskell, with a restriction that salvages principal types.},
booktitle = {Proceedings of the 2004 ACM SIGPLAN Workshop on Haskell},
pages = {33–44},
numpages = {12},
keywords = {higher-rank polymorphism, polymorphic recursion, existential types, implicit parameters, type classes},
location = {Snowbird, Utah, USA},
series = {Haskell '04}
}@inproceedings{10.1145/2628136.2628141,
author = {Breitner, Joachim and Eisenberg, Richard A. and Peyton Jones, Simon and Weirich, Stephanie},
title = {Safe Zero-Cost Coercions for Haskell},
year = {2014},
isbn = {9781450328739},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2628136.2628141},
doi = {10.1145/2628136.2628141},
abstract = {Generative type abstractions -- present in Haskell, OCaml, and other languages -- are useful concepts to help prevent programmer errors. They serve to create new types that are distinct at compile time but share a run-time representation with some base type. We present a new mechanism that allows for zero-cost conversions between generative type abstractions and their representations, even when such types are deeply nested. We prove type safety in the presence of these conversions and have implemented our work in GHC.},
booktitle = {Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming},
pages = {189–202},
numpages = {14},
keywords = {newtype deriving, coercion, type class, haskell},
location = {Gothenburg, Sweden},
series = {ICFP '14}
}

@article{safe-coercions,
author = {Breitner, Joachim and Eisenberg, Richard A. and Peyton Jones, Simon and Weirich, Stephanie},
title = {Safe Zero-Cost Coercions for Haskell},
year = {2014},
issue_date = {September 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2692915.2628141},
doi = {10.1145/2692915.2628141},
abstract = {Generative type abstractions -- present in Haskell, OCaml, and other languages -- are useful concepts to help prevent programmer errors. They serve to create new types that are distinct at compile time but share a run-time representation with some base type. We present a new mechanism that allows for zero-cost conversions between generative type abstractions and their representations, even when such types are deeply nested. We prove type safety in the presence of these conversions and have implemented our work in GHC.},
journal = {SIGPLAN Not.},
month = aug,
pages = {189–202},
numpages = {14},
keywords = {coercion, haskell, newtype deriving, type class}
}

@article{girard-linear-logic,
title = {Linear logic},
journal = {Theoretical Computer Science},
volume = {50},
number = {1},
pages = {1-101},
year = {1987},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(87)90045-4},
url = {https://www.sciencedirect.com/science/article/pii/0304397587900454},
author = {Jean-Yves Girard},
abstract = {The familiar connective of negation is broken into two operations: linear negation which is the purely negative part of negation and the modality “of course” which has the meaning of a reaffirmation. Following this basic discovery, a completely new approach to the whole area between constructive logics and programmation is initiated.}
}