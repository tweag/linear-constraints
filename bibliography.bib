@article{LinearHaskell,
 author = {Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Peyton Jones, Simon and Spiwack, Arnaud},
 title = {Linear Haskell: Practical Linearity in a Higher-order Polymorphic Language},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {January 2018},
 volume = {2},
 number = {POPL},
 month = dec,
 year = {2017},
 issn = {2475-1421},
 pages = {5:1--5:29},
 articleno = {5},
 numpages = {29},
 url = {http://doi.acm.org/10.1145/3158093},
 doi = {10.1145/3158093},
 acmid = {3158093},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {GHC, Haskell, laziness, linear logic, linear types, polymorphism, typestate},
}

@article{OutsideIn,
 title={OutsideIn(X) Modular type inference with local assumptions},
 volume={21},
 doi={10.1017/S0956796811000098},
 number={4-5},
 journal={Journal of Functional Programming},
 publisher={Cambridge University Press},
 author={Vytiniotis, Dimitrios and Peyton Jones, Simon and Schrijvers, Tom and Sulzmann, Martin},
 year={2011},
 pages={333–412}
}

@article{resource-management-for-ll-proof-search,
title = "Efficient resource management for linear logic proof search",
journal = "Theoretical Computer Science",
volume = "232",
number = "1",
pages = "133 - 163",
year = "2000",
issn = "0304-3975",
doi = "https://doi.org/10.1016/S0304-3975(99)00173-5",
url = "http://www.sciencedirect.com/science/article/pii/S0304397599001735",
author = "Iliano Cervesato and Joshua S. Hodas and Frank Pfenning",
keywords = "Linear logic, Theorem proving, Logic programming",
abstract = "The design of linear logic programming languages and theorem provers opens a number of new implementation challenges not present in more traditional logic languages such as Horn clauses (Prolog) and hereditary Harrop formulas (λProlog and Elf). Among these, the problem of efficiently managing the linear context when solving a goal is of crucial importance for the use of these systems in non-trivial applications. This paper studies this problem in the case of Lolli [10], though its results have application to other systems including those based on linear type theory. We first give a proof-theoretic presentation of the operational semantics of this language as a resolution calculus. We then present a series of resource management systems designed to eliminate the non-determinism in the distribution of linear formulas that undermines the efficiency of a direct implementation of this system."
}

@article{hh-ll,
title = "Logic Programming in a Fragment of Intuitionistic Linear Logic",
journal = "Information and Computation",
volume = "110",
number = "2",
pages = "327 - 365",
year = "1994",
issn = "0890-5401",
doi = "https://doi.org/10.1006/inco.1994.1036",
url = "http://www.sciencedirect.com/science/article/pii/S0890540184710364",
author = "J.S. Hodas and D. Miller",
abstract = "When logic programming is based on the proof theory of intuitionistic logic, it is natural to allow implications in goals and in the bodies of clauses. Attempting to prove a goal of the form D ⊃ G from the context (set of formulas) Γ leads to an attempt to prove the goal G in the extended context Γ ∪ {D}. Thus contexts, represented as the left-hand side of intuitionistic sequents, grow as stacks during the bottom-up search for a cut-free proof. While such an intuitionistic notion of context provides for elegant specifications of many computations, contexts can be made more expressive and flexible if they are based on linear logic. After presenting two equivalent formulations of a fragment of linear logic, we show that the fragment has a goal-directed interpretation, thereby partially justifying calling it a logic program-ming language. Logic programs based on the intuitionistic theory of hereditary Harrop formulas can be modularly embedded into this linear logic setting. Programming examples taken from theorem proving, natural language parsing, and data base programming are presented: each example requires a linear, rather than intuitionistic, notion of context to be modeled adequately. An interpreter for this logic programming language must address the problem of splitting contexts; that is, in the attempt to prove a multiplicative conjunction (tensor), say G1 ⊗ G2, from the context Δ the latter must be split into disjoint contexts Δ1 and Δ2 for which G1 follows from Δ1 and G2 follows from Δ2. Since there is an exponential number of such splits, it is important to delay the choice of a split as much as possible. A mechanism for the lazy splitting of contexts is presented based on viewing proof search as a process that takes a context, consumes part of it, and returns the rest (to be consumed elsewhere). In addition, we use collections of Kripke interpretations indexed by a commutative monoid to provide models for this logic programming language and show that logic programs admit canonical models."
}

@misc{shulman2018linear,
      title={Linear logic for constructive mathematics},
      author={Michael Shulman},
      year={2018},
      eprint={1805.07518},
      archivePrefix={arXiv},
      primaryClass={math.LO}
}

@InProceedings{AtsLinearViews,
author="Zhu, Dengping
and Xi, Hongwei",
editor="Hermenegildo, Manuel V.
and Cabeza, Daniel",
title="Safe Programming with Pointers Through Stateful Views",
booktitle="Practical Aspects of Declarative Languages",
year="2005",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="83--97",
abstract="The need for direct memory manipulation through pointers is essential in many applications. However, it is also commonly understood that the use (or probably misuse) of pointers is often a rich source of program errors. Therefore, approaches that can effectively enforce safe use of pointers in programming are highly sought after. ATS is a programming language with a type system rooted in a recently developed framework Applied Type System, and a novel and desirable feature in ATS lies in its support for safe programming with pointers through a novel notion of stateful views. In particular, even pointer arithmetic is allowed in ATS and guaranteed to be safe by the type system of ATS. In this paper, we give an overview of this feature in ATS, presenting some interesting examples based on a prototype implementation of ATS to demonstrate the practicality of safe programming with pointer through stateful views.",
isbn="978-3-540-30557-6"
}

@article{QualifiedTypes,
title = "A theory of qualified types",
journal = "Science of Computer Programming",
volume = "22",
number = "3",
pages = "231 - 256",
year = "1994",
issn = "0167-6423",
doi = "https://doi.org/10.1016/0167-6423(94)00005-0",
url = "http://www.sciencedirect.com/science/article/pii/0167642394000050",
author = "Mark P. Jones",
abstract = "This paper describes a general theory of overloading based on a system of qualified types. The central idea is the use of predicates in the type of a term, restricting the scope of universal quantification. A corresponding semantic notion of evidence is introduced and provides a uniform framework for implementing applications of this system, including Haskell style type classes, extensible records and subtyping. Working with qualified types in a simple, implicitly typed, functional language, we extend the Damas-Milner approach to type inference. As a result, we show that the set of all possible typings for a given term can be characterized by a principal type scheme, calculated by a type inference algorithm."
}

@article{altenkirch2010quantum,
  title={The quantum IO monad},
  author={Altenkirch, Thorsten and Green, Alexander S},
  journal={Semantic Techniques in Quantum Computation},
  pages={173--205},
  year={2010},
  publisher={Cambridge University Press}
}

@inproceedings{quantified-constraints,
author = {Bottu, Gert-Jan and Karachalias, Georgios and Schrijvers, Tom and Oliveira, Bruno C. d. S. and Wadler, Philip},
title = {Quantified Class Constraints},
year = {2017},
isbn = {9781450351829},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3122955.3122967},
doi = {10.1145/3122955.3122967},
abstract = {Quantified class constraints have been proposed many years ago to raise the expressive power of type classes from Horn clauses to the universal fragment of Hereditiary Harrop logic. Yet, while it has been much asked for over the years, the feature was never implemented or studied in depth. Instead, several workarounds have been proposed, all of which are ultimately stopgap measures. This paper revisits the idea of quantified class constraints and elaborates it into a practical language design. We show the merit of quantified class constraints in terms of more expressive modeling and in terms of terminating type class resolution. In addition, we provide a declarative specification of the type system as well as a type inference algorithm that elaborates into System F. Moreover, we discuss termination conditions of our system and also provide a prototype implementation.},
booktitle = {Proceedings of the 10th ACM SIGPLAN International Symposium on Haskell},
pages = {148–161},
numpages = {14},
keywords = {Haskell, type classes, type inference},
location = {Oxford, UK},
series = {Haskell 2017}
}
