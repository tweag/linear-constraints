
%% Ott grammar for linear constraints work

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Metavariables  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar x,y,z,f ::= {{ com Term variables }}
metavar a,b  ::= {{ com Type variables }}
metavar K  ::= {{ com Data constructors }}
metavar T  ::= {{ com Type constructors }}
indexvar i, j ::=  {{ com Index variables }}
indexvar g, w, r, o, ext ::=  {{ com Annotation variables }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Grammar  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Constraints  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Q :: 'Ct_' ::= {{ com Constraints }}
| q                  ::   :: Atom
| Q1 * Q2            ::   :: Tensor
| Empty              ::   :: Empty  {{tex \mathbf{1} }}
| ! Q                ::   :: Unrestricted
| Q [ theta ]        :: M :: Subst
| pi . Q             :: M :: Scale  {{tex [[pi]]{⋅}[[Q]]}}
| ( Q )              :: S :: Paren
% Constraint solver
| ctx ( UCtx )       :: M :: USolverCtx  {{ tex [[UCtx]] }}
| ctx ( LCtx )       :: M :: LSolverCtx  {{ tex [[LCtx]] }}
% Empty case
| Top                ::   :: Top

QQ {{ tex \mathcal{Q} }} :: 'G_' ::= {{ com Givens }}
| Q                ::   :: GivenConstraint
| QQ & Q           ::   :: With
| QQ1 * QQ2        ::   :: Tensor

C :: 'Ctg_' ::= {{ com Generated constraints}}
| Q                  ::   :: Simple
| C1 * C2            ::   :: Tensor
| C1 & C2            ::   :: With
| Q => C             ::   :: Impl  {{ tex [[Q]] \Lolly [[C]]}}
| ! C                ::   :: Unrestricted
| pi . C             :: M :: Scale  {{tex [[pi]]{⋅}[[C]]}}
| && C               :: M :: BigWith
| C [ theta ]        :: M :: Subst
| ( C )              :: S :: Paren

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Types  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

t {{ tex \tau }}, u {{ tex \upsilon }}, s {{ tex \sigma}} :: 'Type_' ::= {{ com Types }}
| a                      ::   :: Var
| Q =o t                 ::   :: Qual
| t o= Q                 ::   :: Carry
| forall as . t          ::   :: ForallNested
  {{ tex [[forall]] [[as]]. [[t]] }}
| exists as . t          ::   :: ExistsNested
  {{ tex [[exists]] [[as]]. [[t]] }}
| ts1 -> t2              :: S :: NestedUrFunction
| ts1 ->_ pis t2           :: S :: Function  {{ tex [[ts1]] \to_{[[pis]]} [[t2]] }}
| T ts                   ::   :: TyConApp
| t [ theta ]            :: M :: Subst
| ( t )                  :: S :: Paren
% Desugared types (see also expressions)
| Ds ( t )               :: M :: Desugared
| Ev ( Q )               :: M :: Evidence
| Ur t                   ::   :: Unrestricted
| unit                   ::   :: Unit   {{ tex \mathbf{1} }}
| t1 * t2                ::   :: Prod
| t1 o- t2               ::   :: DsCarry
% used for talking about Ds(_) as a family
| Hole                   :: S :: Hole {{ tex \_ }}

ts {{ tex \overline{\tau} }}, us {{ tex \overline{\upsilon} }}, ss {{ tex \overline{\sigma} }}
  :: 'Types_' ::= {{ com List of types }}
| empty                  ::   :: None
| t                      ::   :: One
| ts1 , .... , tsi       ::   :: Many
| as                     :: M :: Vars

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Multiplicities  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pi {{ tex \pi }}, rho {{ tex \rho }} :: 'Mult_' ::= {{ com Multiplicities }}
  | 1                    ::   :: One
  | omega                ::   :: Many
  | pi1 . pi2            :: M :: Mult  {{ tex [[pi1]]{⋅}[[pi2]] }}
  | pi1 + pi2            :: M :: Add
  | ( pi )               :: S :: Paren
  % I'd like to avoid multiplicity variables if we can, as they are
  % not very relevant to our discussion

pis {{ tex \overline{\pi} }} :: 'Mults_' ::= {{ com Lists of multiplicities }}
| empty                  ::   :: None
| pi                     ::   :: One
| pis1 , .... , pisi      ::   :: Many

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Substitutions  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

theta {{ tex \theta }} :: 'Subst_' ::= {{ com Substitutions }}
| ts / as                ::   :: Mappings

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Expressions  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

e :: 'Expr_' ::= {{ com Expressions }}
| x                      ::   :: Var
| K                      ::   :: DataCon
| \ x . e                ::   :: Lam
| e1 e2                  ::   :: App
| pack e                 ::   :: Pack
| unpack x = e1 in e2    ::   :: Unpack
| LET x = e1 in e2       ::   :: Let
| LET x : s = e1 in e2   ::   :: LetSig
| CASE e of { alts }     ::   :: Case
| ( e )                  :: S :: Paren
% Cheating a little by adding desugared expressions to the same grammar below.
% This is not formally correct, but it should do.
| Ev ( Q1 ||- Q2 )       :: M :: Evidence
| Ds ( z ; Ty )          :: M :: Desugar
| Ur                     :: M :: UnrestrictedCon
| urify ( Q ; e )        :: M :: Urify  {{ tex \underline{[[e]]}_{[[Q]]} }}
| urify ( e )            :: M :: UrifyShortened {{ tex \underline{[[e]]} }}
| (,)                    ::   :: ProdCon
| ( e1 , e2 )            :: M :: Prod
| ()                     ::   :: UnitCon
| unpack ( pat1 , pat2 ) = e1 in e2    ::   :: UnpackProd

CASE :: 'CaseHead_' ::= {{ com Case head }}
| case_ pi   ::  :: Case {{ tex \kcase_[[pi]] }}

LET :: 'LetHead_' ::= {{ com Let head }}
| let_ pi    ::  :: Let  {{ tex \klet_[[pi]] }}

alt :: 'Alt_' ::= {{ com Case alternative }}
| pat -> e              ::   :: Alt

pat :: 'Pat_' ::= {{ com Patterns }}
% We should consider making a category K, instead of using an expression everywhere a constructor is needed.
| x                          ::   :: Var
| e0 xs                      ::   :: Con
| ()                         ::   :: Unit
| ( pat1 , pat2 )            :: M :: Prod
| urified ( Q ; pat )        :: M :: Urified  {{ tex \underline{[[pat]]}_{[[Q]]} }}
| urified ( pat )            :: M :: UrifiedShortened  {{ tex \underline{[[pat]]} }}

alts {{ tex \overline{\ottmv{K}\ \overline{\ottmv{x}_i } \to \ottnt{e}_i } }}
  :: 'Alts_' ::= {{ com Case alternatives }}
| empty                  ::   :: None
| alt                    ::   :: One
| < alt >                ::   :: Schema
| alts1 ; .... ; altsi   ::   :: Many

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Variables  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

xs {{ tex \overline{\ottmv{x} } }} :: 'Termvars_' ::=
| empty                  ::   :: None
| x                      ::   :: One
| xs1 , .... , xsi       ::   :: Many

as {{ tex \overline{\ottmv{a} } }} :: 'Tyvars_' ::=
| empty                  ::   :: None
| a                      ::   :: One
| as1 , .... , asi       ::   :: Many
| a1 .... ai             ::   :: ManyBinds

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Contexts  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

binding :: 'Binding_' ::= {{ com Context binding }}
| x :_ pi t           ::    :: Bnd
  {{ tex [[x]]{:}_{[[pi]]}[[t]] }}

G {{ tex \Gamma }}, D {{ tex \Delta }} :: 'Ctx_' ::= {{ com Contexts }}
| empty             ::   :: None
| binding           ::   :: One
| G1 , .... , Gi    ::   :: Many
| G1 + G2           :: M :: Add
| Sum G2            :: M :: BigSum
| pi . G            :: M :: Scale {{ tex [[pi]]{⋅}[[G]]}}
| < binding >       :: M :: Repeat  {{ tex \overline{[[binding]]} }}
| ( G )             :: S :: Paren
% Desugared contexts (see also expressions)
| Evs ( Q )         :: M :: Evidence

LCtx {{ tex \Psi }} :: 'LinCtx_' ::= {{ com Linear contexts }}
| empty             ::   :: None
| Q                 ::   :: Atom
| LCtx1 , .... , LCtxi :: :: Many

UCtx {{ tex \Phi }} :: 'UrCtx_' ::= {{ com Unrestricted contexts }}
| empty                :: :: None
| pi . Q               :: M :: Atom {{tex [[pi]]{⋅}[[Q]]}}
| UCtx1 , .... , UCtxi :: :: Many


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Terminals  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: 'terminals_' ::=
| &           ::   :: With    {{ tex \aand }}
| &&          ::   :: BigWith {{ tex \bigaand }}
| *           ::   :: Tensor  {{ tex \otimes }}
| |-          ::   :: entails {{ tex \vdash }}
| |->         ::   :: infer {{ tex \vdashi }}
| |-s         ::   :: solve {{ tex \vdashs }}
| |-simp      ::   :: solve_simples {{ tex \vdashsimp }}
| ||-         ::   :: Entails {{ tex \Vdash }}
| ~>          ::   :: generates {{ tex \leadsto }}
| \           ::   :: Lambda  {{ tex \lambda }}
| ->          ::   :: Arrow   {{ tex \to }}
| forall      ::   :: Forall  {{ tex \forall }}
| exists      ::   :: Exists  {{ tex \exists }}
| =o          ::   :: Lolli   {{ tex \Lolly }}
| o=          ::   :: illoL   {{ tex \RLolly }}
| o-          ::   :: illol   {{ tex \rlolly }}
| \in         ::   :: In      {{ tex \in }}
| \notin      ::   :: NotIn   {{ tex \notin }}
| omega       ::   :: Many    {{ tex \omega }}
| Sum         ::   :: BigSum  {{ tex \sum }}
| empty       ::   :: emptyseq {{ tex ∙ }} % alternative: ϵ
| Top         ::   :: Top     {{ tex ⊤ }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Formulae  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

formula :: formula_ ::=
| judgement                       ::   :: judgement
| formula \\\\                    ::   :: lbh
  {{ tex [[formula]] \ottlinebreakhack }}
  % See ottalt, sec. 1.1
| formula1 .... formulai          ::   :: dots
| as fresh                        ::   :: fresh
  {{ tex [[as]] \text{ fresh} }}
| < formula >                     ::   :: Repeat
  {{ tex \overline{[[formula]]} }}
| e : t                           ::   :: DataconTy
| x \notin G                      ::   :: NotInCtx
| Q \notin LCtx                   ::   :: notin_LCtx
| Q \notin UCtx                   ::   :: notin_UCtx
| LCtx1 ⊆ LCtx2                   ::   :: subcontext

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Parsing rules  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

parsing

Type_ExistsNested <= Type_Carry
Type_ExistsNested <= Type_DsCarry
Ct_Tensor <= Ct_Unrestricted
Ct_Tensor <= Ct_Scale
Ct_Tensor <= Ct_Subst
Ctg_Tensor <= Ctg_Unrestricted
Ctg_Tensor <= Ctg_Scale
Ctg_Tensor <= Ctg_Subst
Ctx_Add <= Ctx_Scale
