\subsection{Former intro}
\change{All the section, below this point, is to be removed, integrating
  whatever we feel like}
Let us now turn back to the more substantial example introduced in
\cref{sec:introduction}: manual memory management.  In functional programming
languages like Haskell, memory deallocation is normally the responsibility of a
garbage collector. However, garbage collection is
not always desirable, either due to its (unpredictable) runtime costs, or because
pointers exist between separately-managed memory spaces
(for example when calling foreign functions~\cite{linear-inline-java}).
In either case, one must then
resort to explicit memory allocation and deallocation. This task is
error prone: one can easily forget a deallocation (causing a memory
leak) or deallocate several times (corrupting data). In this section we show how
to build a % Rust-style % tone down Rust fetishism. It's already mentioned just below.
memory management \textsc{api} as a \emph{library} using linear
constraints. The library is a generalisation of the array library
introduced in \cref{sec:introduction}.

\subsection{Capability Constraints}
\label{sec:atomic-references}

Our approach, inspired by Rust, is
to represent \emph{ownership} of a memory location, and more specifically,
whether the reference is mutable or read-only.
We use the linear constraints |constraint(Read n)| and |constraint(Write n)|,
guarding read access and write access to a reference respectively.
Because of linearity, these constraints
must be consumed, so the \textsc{api} can guarantee that memory
is deallocated correctly.
%
In |constraint(Read n)|, |n| is a type variable (of a special kind |Location|)
which represents a memory location. Locations mediate
the relationship between references and ownership constraints.
%

\begin{minipage}{0.5\linewidth}
> class constraint (Read (n :: Location))
\end{minipage}
\begin{minipage}{0.5\linewidth}
> class constraint (Write (n :: Location))
\end{minipage}
% \begin{minipage}{0.3\linewidth}
% > class constraint (Own (n :: Location))
% \end{minipage}
\\
To ensure referential transparency,
writes can be done only when we are sure that no other part of the program has
read access to the reference.
% Rust disallows mutable aliasing for the same reason: ensuring that writes cannot be observed through other references is what allows treating mutable structures as ``pure''.
% jp: commented this tangent because it obscures the logical connection. It could perhaps go in a parenthesis
Therefore, writing also requires the read capability. Thus we
systematically use |constraint(RW n)|, pairing both the read and write
capabilities.

With these components in place, we can provide an \textsc{api} for mutable
references.

> data AtomRef (a :: Type) (n :: Location)

The type |AtomRef| is the type of references to values of a type |a| at
location |n|. Allocation of a reference can be done using the
following function. % As with |new|, the return value must be unrestricted.

> newRef :: constraint (Unique) =>. exists n. AtomRef a n .<= constraint (RW n)

The function |newRef| creates a new atomic reference, initialised with
|undefined|; we could also pass in an initial value, but doing so in the more
general case below would add complication and obscure our main goal of demonstrating
linear constraints.

To read a reference, a |constraint(Read)| constraint is demanded, and
then returned back. Writing is similar.

> readRef :: constraint (Read n) =>. AtomRef a n -> Ur a .<= constraint (Read n)
> writeRef :: constraint (RW n) =>. AtomRef a n -> a -> () .<= constraint (RW n)

Note that the above primitives do not need to explicitly declare
effects in terms of a monad or another higher-order effect-tracking
device: because the |constraint(RW n)| constraint is linear, passing it suffices
to ensure proper sequencing of effects concerning location |n|.

Also note that |readRef| returns an unrestricted \emph{copy} of the element, and
|writeRef| \emph{copies} an unrestricted element into the location. This means
that while |AtomRef|s are mutable, their contents are always immutable structures.

% This is ensured by the combination of the language and library
% behaviour. For example, here is how to write two values (|a| and |b|) to the same reference |x|:

% > case writeRef x a of
% >   pack _ -> case writeRef x b of
% >     pack _ -> ...

% The language semantics forces the programmer to do case analysis to
% access the returned |Write| constraints, and |writeRef| must be strict
% in the |Write| constraint that it consumes.

Since there is a unique |constraint(RW n)| constraint per reference, we
can also use it to represent ownership of the reference: access to |constraint(RW
n)| represents responsibility (and obligation) to deallocate |n|:

> freeRef :: constraint (RW n) =>. AtomRef a n -> ()

% Instead of deallocating the reference, one could transfer ownership
% of the memory location to the garbage collector. This operation is
% sometimes called ``freezing'':

% > freezeRef :: constraint (RW n) =>. AtomRef a n -> Ur a

\subsection{Arrays}
\label{sec:arrays}

The above toolkit handles references to base types just fine.  But
what about storing references in objects managed by the ownership
system? In \cref{sec:introduction}, we presented an interface for mutable
arrays whose contents are themselves immutable. Our approach
scales beyond that use case, supporting arrays of
references, including arrays of (mutable) arrays.

% JP: the discussion below sounds quite petty. Not many (zero
% non-conflicting?)  people will be aware of the issue with linear
% arrays. So it would need a lot more space to be properly
% justified. Besides, the issue of storing references in structures
% should be motivation enough in general.

% A motivating example of plain Linear Haskell is a pure interface to
% mutable arrays~\cite[Section 2.2]{LinearHaskell}. There we have two
% types: first |MArray a|, used linearly, for mutable arrays; and
% second |Array a|, used unrestricted, for immutable arrays. Mutable
% arrays can be frozen using |freeze :: MArray a ->. Ur (Array
% a)|. Note that this version of |freeze| can not support mutable
% arrays of mutable arrays.  The core of the issue is that mutable
% arrays and immutable arrays have different types.
% The ownership \textsc{api}, on the other hand, is readily extended to
% nested mutable arrays.
% Crucially, and in contrast to the plain linear types \textsc{api} the
% type |PArray| is both the type of mutable arrays and immutable arrays,
% |freezePArray| only changes the capabilities. And since capabilities are
% linear constraints, this is all managed automatically by the compiler.

> data PArray (a :: Location -> Type) (n :: Location)
> newPArray :: constraint (Unique) =>. Int -> exists n. PArray a n .<= constraint (RW n)

For this purpose we introduce the type |PArray a n|, where the kind of
|a| is |Location -> Type|: this way we can easily enforce that each
reference in the array refers to the same location |n|. Both types
|AtomRef a| and |PArray a| have kind |Location -> Type|, and therefore
one can allocate, and manipulate arrays of arrays with this
\textsc{api}. For example, an array of integers has type
|PArray (AtomRef Int) n|, and indeed, the |UArray| type from
\cref{sec:introduction} is a synonym for an array of atomic references.\jp{Can we have the definition?}
An array of arrays of integers has type |PArray (PArray (AtomRef Int)) n|. Thus,
the framework handles nested mutable structures without any additional
difficulty. %% As discussed in \cref{sec:what-it-looks-like}, the scope of |newPArray| returns
%% an unrestricted value to ensure that the linear constraint is consumed within
%% the scope (since linear values cannot be embedded into an unrestricted value).
%% As this is the only introduction form of |constraint (RW n)|, it can safely be
%% assumed to be unique within the scope. An alternative design would be to
%% require that the scope returns the linear constraint: |forall n. constraint (RW
%% n) =>. PArray a n -> b .<= constraint (RW n)|. This version is less flexible,
%% because it doesn't allow the scope to deallocate or freeze the array.

The actual runtime value of a |PArray| is a pointer to a contiguous block of
memory together with the size of the memory block. This means that the length of the
array can be accessed without having ownership of the array: |length :: PArray a n -> Int|.
While the |PArray| reference itself is managed by the garbage collector, the
pointer it contains points to manually managed memory.


% For the special case where the array stores atomic references (|UArray|) which we know how
% to deallocate, the |write| function can be implemented using |replace|:


% > write :: constraint (RW n) =>. UArray a n -> Int -> a -> () .<= constraint (RW n)
% > write arr i x =
% >   let   pack' ref = newRefBeside arr
% >         pack () = writeRef ref x
% >         pack () = replace arr i ref
% >   in freeRef ref

% Because having access to a |constraint(RW n)| is proof that we are inside a scope
% with a unique resource, we can also allocate a reference to the same scope as |n|:

% > newRefBeside :: constraint (RW n) =>. a n -> exists m. Ur (AtomRef m) .<= constraint ((RW n, RW m))

% \csongor{I think this is now the first time we talk about existentials? Need to be careful not to forget introducting them}

\subsubsection{Borrowing}

The |lendMut arr i k| primitive lends access to the reference at index |i| in
|arr|, to a continuation function |k| (in Rust terminology, the function
\emph{borrows} an element of the array). Note that the continuation must return the
read-write capability, so that the ownership transfer is indeed temporary. The
type system guarantees that the borrowed reference cannot be shared or deallocated.\jp{Ok, but what we want to know is how the type achieves this; perhaps we again need to state that the constraints themselves are only ``borrowed''}
%
% Here, the return type of the scope, |r|,
% is not in |Ur|: since the scope must return the |constraint(RW p)| constraint, it is
% not possible to leak it out by packing it into |r|, so it's not necessary to
% wrap the result in |Ur|.
Indeed, with this \textsc{api}, |constraint(RW n)| and |constraint(RW p)| are
never simultaneously available.

> lendMut  :: constraint (RW n) =>. PArray a n -> Int -> (forall p. ^^ constraint (RW p) =>. a p -> r .<= constraint (RW p)) ⊸ r .<= constraint (RW n)
%
Because the elements of an array can be mutable structures (such as
other arrays), reading can be done safely only if we can ensure that
no one else has access to the array while the element is accessed. Otherwise,
the array -- including the element being read -- could be mutated. \jp{This isn't very clear. I believe it should be recalled that all the array contents recursively share the same location}
Therefore,
gaining simple read access to an element needs to be done using a
scoped \textsc{api} as well:

> lend  ::  constraint (Read n) =>. PArray a n -> Int ->  (forall p. ^^ constraint (Read p) =>. a p -> r .<= constraint (Read p)) ⊸ r .<= constraint (Read n)

For the special case of |UArray|s, a more traditional reading
operation can be implemented, by lending the reference to |readRef|
which creates an unrestricted \emph{copy} of the value. This copy is
under control of the garbage collector, and can escape the scope of
the borrowing freely.

> read :: constraint (Read n) =>. UArray a n -> Int -> Ur a .<= constraint (Read n)
> read arr i = lend arr i readRef


% \subsubsection{Freezing}

% Finally, we can freeze arrays, using the
% following primitive:

% > freezePArray :: constraint (RW n) =>. PArray a n -> () .<= constraint (omega ⋅ (Read n))

% Where |constraint(omega ⋅ (Read n))| means that the returned constraint is not linear. That is, after |freezePArray n|, we have unrestricted read access to |n| (and
% any element of |n|), as expected. We describe this syntax in more
% details in the next
% section, where, similarly, we shall treat |constraint(Read n) =>| as
% an abbreviation for |constraint(omega ⋅ (Read n)) =>.|.

% With an unrestricted |constraint(Read n)| capability, we can read from the array
% more directly with the following primitive

% > readP :: constraint (Read n) => PArray a n -> Int -> a n

\subsubsection{Slices}

It is also possible to give a safe interface to array
\emph{slices}. A slice represents a part of an array and allows
splitting the ownership of the array into multiple parts,
shared between different consumers.  The ownership system
means that slicing does not require copying.

Splitting consumes all capabilities of an array and returns two new
arrays that represent the contiguous blocks of memory before and
starting at a given index.

> split :: constraint (RW n) =>. PArray a n -> Int -> exists l r. Ur (PArray a l, PArray a r) .<= constraint ((RW l, RW r, Slices n l r))

In addition to the array capabilities, the output constraints also include
|constraint (Slices n l r)|, witnessing the fact that locations
|l| and |r| are components of |n|, so that they can be joined back
together:

> join :: constraint ((Slices n l r, RW r, RW l)) =>. PArray a l -> PArray a r -> Ur (PArray a n) .<= constraint (RW n)

%format a_i_val = a_i "\_val"
%format a_j_val = a_j "\_val"
\begin{figure}
\maybesmall
\begin{code}
swap :: constraint(RW n) =>. PArray AtomRef n -> Int -> Int -> () .<= constraint(RW n)
swap arr i j  | i == j   =  pack ()
              | i > j    =  swap arr j i
              | i < j    =  let   pack (Ur (l, r))  =  split arr (i + 1)
                                  pack ()           =  lendMut l i (\a_i ->
                                                         let pack () = lendMut r (j - (i + 1)) (\a_j ->
                                                           let  pack (Ur a_i_val)  =  readRef a_i
                                                                pack (Ur a_j_val)  =  readRef a_j
                                                                pack ()            =  writeRef a_j a_i_val
                                                                pack ()            =  writeRef a_i a_j_val
                                                           in pack ()) in pack ())
                                  pack (Ur _)       =  join l r
                            in pack ()
\end{code}
\caption{Swapping two elements of an array}
\label{fig:swap}
\end{figure}


With these building blocks, we can now implement various utility functions on
arrays, such as swapping two elements of an array, which is shown in
\Cref{fig:swap}.  It is
not so simple to implement\footnote{Indeed, Rust's implementation uses
an \emph{unsafe} block.}\jp{is the statement of the footnote this still current? We should specify which version of Rust we're talking about.}, because we need two elements of an array
simultaneously, but only one element can be borrowed at a time.\jp{This is because, essentially, borrowing an element actually borrows the whole array. The reader might expect something more flexible here.} To
solve this problem, we split the array into two slices such that the
two indices fall in two different slices. Then simply borrow the
element |i| from the first slice, and |j| from the second slice (using
|lendMut|). Finally, we join the two slices back together.

\subsubsection{In-Place Quicksort}

As an example of using the machinery defined above, we implement an in-place, pure
quicksort algorithm, given in \Cref{fig:quicksort}.
%
\begin{figure}
\maybesmall
\noindent
\begin{minipage}[t]{0.45\linewidth}
\begin{code}
sort :: constraint (RW n) =>. UArray Int n -> () .<= constraint (RW n)
sort arr = let len = length arr in
  if len <= 1 then pack ()
  else   let  pack pivotIdx       =  partition arr
              pack (Ur (l, r))    =  split arr pivotIdx
              pack ()             =  sort l
              pack ()             =  sort r
              pack (Ur _)         =  join l r
         in pack ()
\end{code}
\end{minipage}
\begin{minipage}[t]{0.4\linewidth}
\begin{code}
partition :: constraint (RW n) =>. UArray Int n -> Int .<= constraint (RW n)
partition arr =
  let  last             =  length arr - 1
       pack (Ur pivot)  =  read arr last
       go :: constraint (RW n) =>. Int -> Int -> Int .<= constraint (RW n)
       go l r
         |  l > r
         =  let pack () = swap arr last l in pack l
         |  otherwise
         =  let pack (Ur lVal) = read arr l in
            if lVal > pivot
            then  let pack () = swap arr l r
                  in go l (r - 1)
            else  go (l + 1) r
  in go 0 (last - 1)
\end{code}
\end{minipage}
\caption{In-place quicksort}
\label{fig:quicksort}
\end{figure}
%
The |partition| function is responsible for picking a pivot element and
reorganising the array elements such that each element preceding the pivot will
be less than or equal to it, and the elements after will be greater than the
pivot. Once finished, it returns the index of the pivot element; |sort| then
splits the array at the pivot element and recursively operates on the two
slices.
