
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Entailment  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Qs :: '' ::=


defn
QQ1 ||- Q2 :: :: Qrules :: 'Q_' {{ com Constraint entailment }}
by

% left abstract

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Typing rules  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Ty :: '' ::=

defn
Q ; G |- e : t :: :: Ty :: 'E_' {{ com Expression typing }}
by

x :_1 forall as. Q1 =o u \in G
Q ||- Q1[ts/as]
-------------- :: Var
Q;G |- x : u[ts/as]

Q;G, x:_pi t1 |- e : t2
---------------------- :: Abs
Q;G |- \x.e : t1 ->_pi t2

Q1;G1 |- e1 : t1 ->_pi t
Q2; G2 |- e2 : t1
------------------------------ :: App
Q1*pi.Q2;G1+pi.G2 |- e1 e2 : t

Q*Q1;G |- e : t[ts/as]
------------------------- :: Pack
Q;G |- pack e : exists as. t o= Q1

Q1';G1 |- e1 : exists as. t1 o= Q1
freshness condition on as
Q2' * Q1;G2,x:_pi t1 |- e2 : t
------------------------------------------------- :: Unpack
pi.Q1' * Q2';pi.G1 + G2 |- unpack x = e1 in e2 : t

Q1;G1 |- e1 : t1
Q2;G2,x:_pi t1 |- e2 : t
--------------------------- :: Let
pi.Q1 * Q2 ;pi.G1+G2 |- let x = e1 in e2 : t

Q1;G1 |- e : T ts
< Ki : forall as. usi ->_pisi T as >
< Q2; G2, < xi :_pii ui[ts/as] > |- ei : t >
------------------------- :: Case
Q1*Q2;pi.G1+G2 |- case e of { alts } : t

Q1;G |- e : t
Q1 ||- Q
------------------------- :: Sub
Q;G |- e : t
