
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Entailment  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Qs :: '' ::=


defn
QQ1 ||- Q2 :: :: Qrules :: 'Q_' {{ com Constraint entailment }}
by

% left abstract

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Entailment  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Log :: '' ::=

defn
Q |- C :: :: Crules :: 'C_'  {{ com Generalised constraint entailment }}
by

Q1 ||- Q2
--------- :: Dom
Q1 |- Q2

Q1 |- C1
Q2 |- C2
-------------- :: Tensor
Q1*Q2 |- C1*C2

Q |- C1
Q |- C2
------------- :: With
Q |- C1 & C2

Q0*Q1 |- C
------------- :: Impl
pi. Q0 |- pi.(Q1 => C)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Typing contexts  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Cts :: '' ::=

defn
binding \in G :: :: Mem :: 'In_'  {{ com Context membership }}
by

-------------------- :: Var
x :_1 s \in x :_1 s

x :_1 s \in G
--------------------- :: Weaken
x :_1 s \in omega.D+G

defn
pi . G = D :: :: Scale :: 'S_'  {{ com Context scaling }}
by

---------------------- :: Empty
pi . empty = empty

pi . G = D
--------------------------------------- :: Binding
pi . (G, x :_rho s) = D, x :_(pi.rho) s

defn
G1 + G2 = D :: :: Add :: 'A_' {{ com Context addition }}
by

G1 + G2 = D
--------------------------------------------------- :: Binding
(G1, x :_pi s) + (G2, x :_rho s) = D, x :_(pi+rho) s

G1 + G2 = D
x \notin G2
--------------------------------------------------- :: Absent
(G1, x :_pi s) + G2 = D, x :_pi s

---------------- :: Empty
G1 + empty = G1


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Typing rules  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Ty :: '' ::=

defn
Q ; G |- e : t :: :: Ty :: 'E_' {{ com Expression typing }}
by

x :_1 forall as. Q1 =o u \in G
Q ||- Q1[ts/as]
-------------- :: Var
Q;G |- x : u[ts/as]

Q;G, x:_pi t1 |- e : t2
---------------------- :: Abs
Q;G |- \x.e : t1 ->_pi t2

Q1;G1 |- e1 : t1 ->_pi t
Q2; G2 |- e2 : t1
------------------------------ :: App
Q1*pi.Q2;G1+pi.G2 |- e1 e2 : t

Q ; G |- e : t[us/as]
------------------------- :: Pack
omega.Q * Q1[us/as];omega.G |- pack e : exists as. t o= Q1

Q1;G1 |- e1 : exists as. t1 o= Q
freshness condition on as
Q2 * Q;G2,x:_omega t1 |- e2 : t
------------------------------------------------- :: Unpack
Q1 * Q2;G1 + G2 |- unpack x = e1 in e2 : t

Q1*Q;G1 |- e1 : t1
Q2;G2,x:_pi Q =o t1 |- e2 : t
--------------------------- :: Let
pi.Q1*Q2 ;pi.G1+G2 |- let x = e1 in e2 : t

Q1*Q;G1 |- e1 : t1
as fresh
Q2;G2,x:_pi forall as.Q =o t1 |- e2 : t
--------------------------- :: LetSig
Q2 ;pi.G1+G2 |- let x : forall as.Q =o t1 = e1 in e2 : t

Q1;G1 |- e : T ts
< Ki : forall as. usi ->_pisi T as >
< Q2; G2, < xi :_(pi.pii) ui[ts/as] > |- ei : t >
------------------------- :: Case
pi.Q1*Q2;pi.G1+G2 |- case e of { alts } : t

Q1;G |- e : t
Q1 ||- Q
------------------------- :: Sub
Q;G |- e : t

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Constraint generation  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Gen :: '' ::=

defn
G |-> e : t ~> C :: :: Gen :: 'G_' {{ com Constraint generation }}
by

x :_1 forall as. Q =o u \in G
------------------------------ :: Var
G |-> x : u[ts/as] ~> Q[ts/as]

G, x:_pi t0 |-> e : t ~> C
------------------------------ :: Abs
G |-> \x. e : t0 ->_pi t ~> C

G1 |-> e1 : t2 ->_pi t ~> C1
G2 |-> e2 : t2 ~> C2
------------------------------ :: App
G1 + pi.G2 |-> e1 e2 : t ~> C1 * pi.C2

G |-> e : T ss ~> C
Ki : forall as. usi ->_pisi T as
D, <xi:_(pi.pii) ui[ss/as]> |-> ei : t ~> Ci
------------------------------ :: Case
pi.G + D |-> case e of {alts} : t ~> pi.C * && Ci

G1 |-> e1 : exists as. t1 o= Q1 ~> C1
as fresh
G2, x:_omega t1 |-> e2 : t ~> C2
------------------------------ :: Unpack
G1+G2 |-> unpack x = e1 in e2 : t ~> C1 * (Q1 => C2)

G |-> e : t[us/as] ~> C
------------------------------ :: Pack
omega.G |-> pack e : exists as. t o= Q ~> omega.C * Q[us/as]


G1 |-> e1 : t1 ~> C1
G2, x:_pi t1 |-> e2 : t ~> C2
------------------------------ :: Let
pi.G1+G2 |-> let x = e1 in e2 : t ~> pi.C1 * C2

G1 |-> e1 : t1 ~> C1
Q_r * Q |- C1
G2, x:_pi Q =o t1 |-> e2 : t ~> C2
------------------------------ :: LetGen
pi.G1+G2 |-> let x = e1 in e2 : t ~> pi.Q_r * C2

G1 |-> e1 : t1 ~> C1
as fresh
G2, x:_pi forall as. Q =o t1 |-> e2 : t ~> C2
------------------------------ :: LetSig
pi.G1+G2 |-> let x : forall as. Q =o t1 = e1 in e2 : t ~> C2 * pi.(Q => C1)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Constraint solver  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Solve :: '' ::=

defn
UCtx ; LCtx |-s C_w ~> LCtx_o :: :: Solve :: 'S_' {{ com Constraint solving }}
by

-------------------------------- :: AtomMany
UCtx , omega.q ; LCtx |-s omega.q ~> LCtx

q \notin LCtx2
omega.q \notin UCtx
-------------------------------- :: AtomOneL
UCtx ; LCtx1 , q , LCtx2 |-s q ~> LCtx1 , LCtx2

q \notin LCtx
-------------------------------- :: AtomOneU
UCtx , omega.q ; LCtx |-s q ~> LCtx


UCtx ; LCtx_i |-s C1 ~> LCtx_o  UCtx ; LCtx_i |-s C2 ~> LCtx_o
--------------------------------------------------------------- :: Add
UCtx ; LCtx_i |-s C1 & C2 ~> LCtx_o

UCtx ; LCtx_i |-s C1 ~> LCtx_o'  UCtx ; LCtx_o' |-s C2 ~> LCtx_o
------------------------------------------------------------- :: Mult
UCtx ; LCtx_i |-s C1 * C2 ~> LCtx_o

UCtx ; LCtx_i , Q |-s C ~> LCtx_o
LCtx_o âŠ† LCtx_i
---------------------------------------------- :: ImplOne
UCtx ; LCtx_i |-s Q => C ~> LCtx_o

UCtx ; Q |-s C ~> empty
---------------------------------------------- :: ImplMany
UCtx ; LCtx_i |-s omega.(Q => C) ~> LCtx_i

% todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Desugared expressions  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Core :: '' ::=

defn
G |- e : t :: :: Core :: 'L_' {{ com Core language }}
by

x :_1 forall as. u \in G
------------------------- :: Var
G |- x : u[ts/as]

G, x:_pi t1 |- e : t2
------------------------ :: Abs
G |- \x.e : t1 ->_pi t2

G1 |- e1 : t1 ->_pi t
G2 |- e1 : t1
------------------------- :: App
G1 + pi.G2 |- e1 e2 : t

G1 |- e1 : t1[us/as]
G2 |- e2 : t2[us/as]
------------------------------------------ :: Pack
G1+omega.G2 |- pack (e1, e2) : exists as.t2 o- t1

G1 |- e1 : exists as. t2 o- t1
freshness condition on as
G2,y:_1 t1,x:_omega t2 |- e2 : t
------------------------------------ :: Unpack
G1+G2 |- unpack (y,x) = e1 in e2 : t

G1 |- e1 : t1
G2, x:_pi s |- e2 : t
----------------------------------- :: Let
pi.G1 + G2 |- let x : s = e1 in e2 : t

G1 |- e : T ts
< Ki : forall as. usi ->_pisi T as >
<G2, < xi :_(pi.pii) ui[ts/as] > |- ei : t >
------------------------------------------------ :: Case
pi.G1+G2 |- case e of { alts } : t
