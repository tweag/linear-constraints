
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Entailment  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Qs :: '' ::=


defn
QQ1 ||- Q2 :: :: Qrules :: 'Q_' {{ com Constraint entailment }}
by

% left abstract

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Typing rules  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Ty :: '' ::=

defn
Q ; G |- e : t :: :: Ty :: 'E_' {{ com Expression typing }}
by

x : forall as. Q1 =o u \in G
Q ||- Q1[ts/as]
-------------- :: Var
Q;G |- x : u[ts/as]

Q;G, x:t1 |- e : t2
---------------------- :: Abs
Q;G |- \x.e : t1 -> t2

Q1;G |- e1 : t1 -> t
Q2; G |- e2 : t1
Q ||- Q1 * Q2
---------------- :: App
Q;G |- e1 e2 : t

Q1';G |- e1 : exists as. t1 o= Q1
freshness condition on as
Q2' * Q1;G,x:t1 |- e2 : t
Q ||- Q1' *  Q2'
------------------------------ :: Unpack
Q;G |- unpack x = e1 in e2 : t

Q1;G |- e1 : t1
Q;G,x:Q1 =o t1 |- e2 : t
--------------------------- :: Let
Q;G |- let x = e1 in e2 : t

Q1;G |- e : T ts
< Ki : forall as. usi -> T as >
< Q2; G, < xij : uij[ts/as] > |- ei : t >
Q ||- Q1 * Q2
------------------------- :: Case
Q;G |- case e of { alts } : t
